// runtime.c
// Standalone C runtime for BCPL
// This file is only compiled for standalone builds, not for JIT.

#include "runtime.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Forward declaration of the compiled BCPL entry point
// This function will be defined in the assembly generated by the BCPL compiler
extern int64_t START(void);

// Simple C-based allocator implementations for standalone builds
// These replace the C++ HeapManager used in JIT mode

void* bcpl_alloc_words(int64_t num_words, const char* func, const char* var) {
    if (num_words <= 0) return NULL;

    // Allocate memory with header: [size][data...]
    // The size is stored as a 64-bit value before the actual data
    size_t total_size = sizeof(uint64_t) + num_words * sizeof(uint64_t);
    uint64_t* vec = (uint64_t*)malloc(total_size);
    
    if (!vec) {
        fprintf(stderr, "ERROR: Failed to allocate %lld words in %s for %s\n",
                (long long)num_words, func ? func : "unknown", var ? var : "unknown");
        return NULL;
    }
    
    // Store the size in the header
    vec[0] = num_words;
    
    // Return a pointer to the data section (after the header)
    return (void*)(vec + 1);
}

void* bcpl_alloc_chars(int64_t num_chars) {
    if (num_chars < 0) return NULL;

    // For strings, we allocate: [size][data...][0]
    // The data is an array of uint32_t values, and we add space for a null terminator
    size_t total_size = sizeof(uint64_t) + (num_chars + 1) * sizeof(uint32_t);
    uint64_t* str = (uint64_t*)malloc(total_size);
    
    if (!str) {
        fprintf(stderr, "ERROR: Failed to allocate string with %lld chars\n",
                (long long)num_chars);
        return NULL;
    }
    
    // Store the size in the header
    str[0] = num_chars;
    
    // Get a pointer to the data section
    uint32_t* payload = (uint32_t*)(str + 1);
    
    // Add null terminator
    payload[num_chars] = 0;
    
    // Clear the string for safety
    memset(payload, 0, num_chars * sizeof(uint32_t));
    
    // Return a pointer to the data section
    return (void*)payload;
}

void bcpl_free(void* ptr) {
    if (!ptr) return;
    
    // The actual block starts before the payload pointer
    // We offset by one header word (uint64_t) to get the original allocation
    void* actual_block = (uint64_t*)ptr - 1;
    free(actual_block);
}

// Include the shared implementations
#include "runtime_core.inc"
#include "runtime_string_utils.inc"
#include "runtime_io.inc"

// Main entry point for standalone executables
/*
int main(int argc, char *argv[]) {
    // Initialize the runtime environment
    printf("BCPL Runtime v%s initializing...\n", BCPL_RUNTIME_VERSION);
    
    // Process command line arguments if needed
    if (argc > 0) {
        printf("Program: %s\n", argv[0]);
    }
    
    // Create arguments for BCPL program if needed
    // This could be expanded to properly convert argc/argv to BCPL format
    
    // Call the BCPL program's entry point
    printf("Starting BCPL program...\n");
    int64_t result = START();
    printf("BCPL program finished with result: %lld\n", (long long)result);
    
    return (int)result;
}
*/